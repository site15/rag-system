site15.ru - typegraphql-prisma-nestjs | Ильшат Хамитов | Software Engineer | site15.ru

# typegraphql-prisma-nestjs | Ильшат Хамитов | Software Engineer | site15.ru

URL: https://site15.ru/projects/typegraphql-prisma-nestjs.html
Downloaded: 2025-12-29T19:49:45.652Z

typegraphql-prisma-nestjs | Ильшат Хамитов | Software Engineer | site15.ru

# typegraphql-prisma-nestjs

Мой форк генератора typegraphql-prisma для NestJS с кастомизациями.

##  Основная идея

Это мой форк оригинального генератора typegraphql-prisma, который я использую для быстрой генерации CRUD‑бэкенда на GraphQL.

Оригинальный генератор перестал корректно работать с определённой версией NestJS: автор NestJS интегрировал части TypeGraphQL, что сломало обратную совместимость с декораторами. В итоге весь туллинг оригинального проекта перестал работать или работает частично.

Моя версия форка решает эти проблемы:

- Поддержка NestJS интеграции на должном уровне.

- Корректные импорты и совместимость с последними версиями NestJS.

- Генератор CRUD Prisma для GraphQL остаётся доступным и полностью работоспособным.

##  Что я сделал

- Форк с изменёнными **импортами и адаптацией под NestJS**.

- Добавил **небольшие кастомизации по работе с CRUD**, чтобы удобно использовать как в рабочих, так и домашних проектах.

##  Где используется

- **На работе**: активно применяю для ускоренной генерации CRUD API на NestJS + Prisma + GraphQL.

- **В домашних проектах**: удобно для прототипирования и тестирования идей.

Важно: библиотека даёт полный доступ к базе, поэтому нужно внимательно контролировать, что шариcь наружу.

##  Мои рекомендации

- Генератор удобно использовать на этапе **MVP проекта**, чтобы быстро получить рабочие CRUD‑эндпоинты.

- Перед релизом: пройтись по всем эндпоинтам, **ограничить вариации запросов и права доступа**, чтобы обезопасить базу.

- Поддерживать форк актуальным относительно **NestJS и Prisma**, чтобы интеграция оставалась стабильной.

##  Отличия моего форка от оригинала

### 1. Импорты для NestJS

- Оригинал использует: `import { Ctx, Query, Resolver } from "type-graphql"`

- Мой форк: `import { Context, Query, Resolver } from "@nestjs/graphql"`

### 2. Поддержка модификации аргументов перед запросом к Prisma

- Добавлены функции `transformArgsIntoPrismaArgs` и `setTransformArgsIntoPrismaArgs`, позволяющие менять аргументы до отправки запроса к базе.

- PR в оригинальном проекте: 399

- Примеры форка и приложения доступны в репозиториях EndyKaufman.

### 3. Поддержка отметки части полей как опциональных

- Можно использовать: `@TypeGraphQL.optional(input: ["create", "update"])`

### 4. Поддержка вызова асинхронных событий после запроса к Prisma

- Позволяет выполнять дополнительную логику после обработки запроса, сохраняя результат.

- Пример использования: возможность вставлять коллбэки `afterProcessEvents` для обработки результата после запроса.

### 5. Опции для пропуска генерации методов и полей резолверов

- Настраиваются списки методов и свойств для генерации:

- `emitActions` — методы CRUD и агрегирование (`findUnique, findMany, createOne…`)

- `emitPropertyMethods` — методы работы с полями сущностей (`create, connectOrCreate, upsert…`)

### 6. Интеграция с Dataloader для вложенных объектов

- Настройки:

- `useDataloaderForResolveFields` — использовать Dataloader для сущностей

- `useDataloaderForAllResolveFields` — использовать Dataloader для массивов сущностей

- `useDataloaderMaxBatchSize` — ограничение на размер батча (`Infinity` по умолчанию)

- `useDataloaderBatchScheduleFnDelay` — задержка для решения проблемы с nextTick

- `useDataloaderCache` — включение/выключение кеширования ключей

##  Преимущества

- Сильная интеграция с NestJS.

- Полностью работоспособный CRUD генератор Prisma для GraphQL.

- Возможность добавления собственных кастомизаций.

- Сокращает время разработки API и минимизирует рутинный код.

- Позволяет гибко управлять генерацией методов и аргументов, включая асинхронные события и Dataloader.

##  Важное замечание

Это моя библиотека‑инструмент, а не полноценное приложение. Основная роль — автоматическая генерация типов и CRUD‑резолверов, без бизнес-логики. Использовать её безопасно можно на этапе прототипирования, а перед продакшеном следует провести ревью всех сгенерированных эндпоинтов.